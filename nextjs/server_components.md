# Server Components

Server Component可以在服务器上被渲染和缓存：

## 服务端渲染的优势：

- **数据获取**：服务端渲染可以在服务器上直接发送请求，由于服务器（相对于客户端）离数据更近，他可以通过减少渲染相关数据获取的时间和获取次数来改善性能；
- **安全**：服务端组件允许你将敏感数据和逻辑保留在服务端上，类似安全令牌（Token）和服务接口的keys（API Keys），而不用将它们暴露在客户端上；
- **缓存**：服务端渲染可以将“结果数据”或者“渲染产物”进行缓存，并将其给后续请求和不同的用户使用；这种方式可以明显改善性能和减少成本通过减少每一次请求所带来的数据获取和页面渲染；
- **性能**：服务端组件提供许多附加工具来优化根据基线优化性能；举个例子：比如你的app是完全由客户端组件构成的，将你的app中那些无交互的UI转移到服务端上，这样可以减少大量所需客户端javascript的大小。这将对那些网络速度不快以及老旧机型的用户带来好处，来改善体验；因为浏览器只需要下载更少的客户端JavaScript，进行编译和执行；
- **首次内容绘制[First Contentful Paint(FCP)**](https://web.dev/articles/fcp?hl=zh-cn)：服务端渲染可以让我们在服务器上创建好html内容，这样用户可以更快的看见内容，而不是等待下载，编译，执行所需的javascript来渲染页面；
- **搜索引擎优化和社交网络共享**：所有引擎爬虫和社交网络爬虫友好；
- **流渲染（Streaming）**：服务端组件允许你讲渲染工作分割成数个小包（chunk）并将他们通过流的方式给到客户端，这个可以让用户通过先看到一部分页面来改善体验，而不是等到所有页面都在服务器上渲染好；

> FCP小解释：首次内容绘制用于用户首次导航到网页到网页内容的任何部分在屏幕上呈现的时间。对于辞职表，渲染“内容”指文本、图片（包含背景图片）、<SVG> SVG元素或者非白色的Canvas元素。

> [Largest Contentful Paint(LCP)](https://web.dev/articles/lcp?hl=zh-cn)最好也有的了解：他标记了页面加载时间轴上可能加载页面主要内容的时间，下面很重要，LCP会报告是串口中可见的最大图片、文本模块或者视频的呈现时间（相对于用户首次导航到相应网页的时间）。LCP包含前一页面的所有卸载时间、链接时间、重定向时间以及首字节时间（TTFB）。

## 如何在Next.js中使用服务端组件（Server Components）

Next.js默认使用服务端组件无需任何配置，同时，你也可以根据你的需求使用客户端组件，详细的可以查看下一篇客户端组件。

## 服务端组件是如何渲染的？

# 在服务器上

Next.js使用React的API来编排渲染，渲染的工作通过独立的路由块(Route Segments)和[Suspense](https://react.dev/reference/react/Suspense)被分成小块，每个小块通过以下两步被渲染：

1. React将服务端组件渲染成一种特殊的数据格式——React Server Component Payload(RSC Payload).
2. Next.js使用RSC Payload和客户端组件Javascript指令在服务器上进行渲染HTML；

### 在客户端上

1. 这些被渲染好的HTML被用于立即显示一个当前路由的快速且无交互的初始加载页面；
2. RSC Payload用于协调(reconcoile)客户端和服务端组件树，并且更新DOM；
3. 这些javascript指令被用于[hydrate](https://react.dev/reference/react-dom/client/hydrateRoot) Client Component(是实话，这个挺难翻译的，就叫他混合客户端组件吧)

> `hydrateRoot` lets you display React components inside a browser DOM node whose HTML content was previously generated by [`react-dom/server`.](https://react.dev/reference/react-dom/server)
>
> 翻译一下，hydrateRoot可以让你在浏览器中显示react-dom/server(服务端组件)，这章要好好读读

> 什么是RSC payload？
>
> 它是一种已渲染的React服务器端组件树的二进制表现。他被用于客户端的React去更新他的浏览器DOM，RSC Payload包含以下三点：
>
> - 服务端组件的渲染结果
> - 客户端组件需要用来渲染和引用javascript文件的占位符；
> - 所有服务端组件传递给客户端组件的 Props

## 服务端渲染策略

有三种渲染策略：

- 静态渲染（static rending）
- 动态渲染（dynamic rending）
- 流渲染（Streaming）

### 静态渲染（默认渲染方式）

静态渲染和路由都发生在打包编译(building)的时候，或者在数据重新校验后。缓存结果可以被推送到CDN上，这个优化可以让你在不同用户和不用请求中共享渲染结果；

静态渲染的在以下两种情况下非常有用

1. 对用户展示的数据不是个性化的；
2. 在编译时就可以知道数据的；

举两个例子，比如静态博客和产品页

### 动态渲染

动态渲染和路由的渲染都是发生在每个用户的请求时

动态渲染适用于以下两个场景：

1. 对于用户展现的数据是个性化的；
2. 有一些数据只有在请求时(request time)才可以知道，比如cookies和地址上的参数；

> 在动态路由上使用缓存数据
>
> 在大多数网站上，路由都不是完全动态和完全静态的；比如说你有个电商页面使用了缓存的商品信息，他每隔一段时间就会重新校验，但同样也会有一些不缓存、个性化的数据；
>
> 在Next.js中，你可以你可以有个动态渲染路径同时有缓存和非缓存数据。这是因为RSC Rayload和数据是分开缓存的；这允许你使用动态渲染而不用担心获取数据时对于性能的影响
>
> 想了解更多的话，可以访问[full-route cache](https://nextjs.org/docs/app/building-your-application/caching#full-route-cache) and [Data Cache](https://nextjs.org/docs/app/building-your-application/caching#data-cache).

### 切换动态渲染

在渲染过程中，如果一个动态功能（dynamic function）或者未缓存的数据请求（uncached data request）被发现了，Next.js会切换到动态渲染，来渲染该路由。以下表格统计了动态功能和数据缓存是如何影响一个路由是静态还是动态渲染的：

| Dynamic Functions（动态功能） | Data（数据） | 路由（Route） |
| ----------------------------- | ------------ | ------------- |
| No                            | Cached       | 静态渲染      |
| Yes                           | Cached       | 动态渲染      |
| No                            | Cached       | 动态渲染 ｜   |
| Yes                           | Not Cached   | 动态渲染      |

在上面的表格中，一个路由如果要做成静态的，那么他所有的数据必须被缓存。然后，你可以在动态渲染的时候同时使用缓存或者为缓存的数据；

作为一个开发这，你不必亲自选择静态还是动态的= 二
